
<script>
    lookup = {};
    lookup.last_written = "";
    lookup.statements = [
    ];

    lookup.text_statements = [
        "Tom is cat",
        "cat has tail", 
        "cat has whiskers", 
        "*A* is *B* | *B* has *C* => *A* has *C*",
        "*A*1 + 1 => *A*2",
        "*A*2 + 1 => *A*3",
        "*A*3 + 1 => *A*4",
        "*A*4 + 1 => *A*5",
        "*A*5 + 1 => *A*6",
        "*A*6 + 1 => *A*7",
        "*A*7 + 1 => *A*8",
        "*A*8 + 1 => *A*9",
        "*A*9 + 1 => *A*0 + 10",
        "*A* 2 => *A* 1 + 1",
        "*A* 3 => *A* 2 + 1",
        "*A* 4 => *A* 3 + 1",
        "*A* 5 => *A* 4 + 1",
        "*A* 6 => *A* 5 + 1",
        "*A* 7 => *A* 6 + 1",
        "*A* 8 => *A* 7 + 1",
        "*A* 9 => *A* 8 + 1",
        // -----
        "5 + 3"

    ];
</script>
<script>

    lookup.add_statement = function(stuff, where_it_comes_from, chain_of_thought)
    {
        if (lookup.statements.length > 1000)
        {
            console.log("Statements limit");
            return;

        }
        for(const existing of lookup.statements)
        {
            if(existing.original === stuff) 
            {
                return;
            }
        }
         
        if (stuff.indexOf(" => ") >= 0)
        {
            const [conditionsPart , conclusion] = stuff.split(" => ");
            const conditions = conditionsPart.split(" | ");
            const to_add = {
                type: "rule",
                original: stuff,
                where_it_comes_from: where_it_comes_from,
                data: {
                    conditions: conditions,
                    conclusion: conclusion
                },
                chain_of_thought: chain_of_thought || [stuff]
            };
            lookup.statements.push(to_add);
            console.log(to_add);
        }
        else
        {
            const to_add = {
                type: "fact",
                original: stuff,
                where_it_comes_from: where_it_comes_from,
                data: stuff,
                chain_of_thought: chain_of_thought || [stuff]
            };
            lookup.statements.push(to_add);
            console.log(to_add);
        }
    };
    </script>
    <script>

    
    lookup.escapeRegExp = function(string) 
    {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };

    lookup.index_in_statements = 0;
    lookup.index_in_rules = 0;
    lookup.rewrite = function()
    {
        var start = new Date();
        var operations_passed = 0;
        console.log("rewrite", lookup.statements.length);
        for(;lookup.index_in_statements < lookup.statements.length; lookup.index_in_statements++)
        {
            const fact = lookup.statements[lookup.index_in_statements];
            if (fact.type != "fact") continue;
            for(; lookup.index_in_rules < lookup.statements.length; lookup.index_in_rules++)
            {
                const rule = lookup.statements[lookup.index_in_rules];
                if (rule.type != "rule") continue;
                operations_passed++;
                var all_conditions_are_met = true;
                const named_slot_regexp = /\*[A-Z]\*/
                if (operations_passed > 1000)
                {
                    var current_date = new Date();
                    if (current_date - start > 30)
                    {
                        setTimeout(lookup.rewrite, 30);
                        return;
                    }
                    operations_passed -= 1000;
                }

                for(const single_condition of rule.data.conditions)
                {
                    //"B has C".split(/[A-Z]/)
                    // [ "", " has ", "" ]
                    
                    // this ir really hardly readable
                    const parts = single_condition.split(named_slot_regexp);
                    if (parts.length == 1) continue;
                    var nonEmpty = parts.filter(p => p != "");
                    var escaped = nonEmpty.map(p => lookup.escapeRegExp(p));
                    var mask = escaped.join("|");
                    var inverted_named_slot_regexp = new RegExp(mask);
                    var values = fact.data.split(inverted_named_slot_regexp);
                    var non_empty_values = values.filter(v => v !== "");
                    var variables = single_condition.split(inverted_named_slot_regexp);
                    var non_empty_variables = variables.filter(v => v !== "");
                    if (non_empty_values.length != non_empty_variables.length) 
                    {
                        all_conditions_are_met = false; 
                        continue;
                    }
                    //console.log(values, variables);
                    var combined_rule = rule.data.conditions.join(" | ") + " => " + rule.data.conclusion;
                    for(var k = 0; k < variables.length; k++)
                    {
                        const single_variable = non_empty_variables[k];
                        const just_value = non_empty_values[k];
                        if (single_variable !== "")
                        {
                            combined_rule = combined_rule.replaceAll(single_variable, just_value);
                        }
                    }

                    
                    var chain_of_thought = [rule.original, fact.original, combined_rule];
                    lookup.add_statement(combined_rule, 'partially-applied-rule', chain_of_thought);
                    all_conditions_are_met = false;
                    break;// ??? - yeah lets make final check on next round

                    //"hello *B* has *C*".split(/\*[A-Z]\*/)
                    //Array(3) [ "hello ", " has ", "" ]


                }

                if (all_conditions_are_met)
                {
                    const parts = rule.data.conclusion.split(named_slot_regexp);
                    if (parts.length == 1) 
                    {
                        var chain_of_thought = [rule.original, rule.data.conclusion];
                        lookup.add_statement(rule.data.conclusion, 'fully-applied-rule', chain_of_thought);
                    }
                }
            }
            lookup.index_in_rules = 0;
        }
        lookup.index_in_statements = 0;
        setTimeout(lookup.rewrite, 30);
    };
    setTimeout(lookup.rewrite, 30);
</script>
<script>
    for(var text of lookup.text_statements)
    {
        lookup.add_statement(text, 'predefined-data');
    }
</script>
<body style="background-color: rgb(44, 44, 178); color: rgb(218, 151, 126);">
egalite-ai</br>
local chat-like reasoning</br>
</br>
Motto:</br>
Be readable</br>
Provide partial answer ASAP</br>
allow to break reasoning</br>
</br>
if A is a B and B has C then A has C</br>
vs earmuffs</br>
*A* is *B* | *B* has *C* => *A* has *C*</br>
What has Tom? => Tom has *?* // query </br>
12 + 6 => 10 + 2 + 6
12 => 
*A*2 *B* => *A*0 + 2 *B*
*A*1 *B* => *A*0 + 1 *B*
*A*
// I forgot to check if rule is A is B hello B, that B should have same value

<input id="repl" onkeyup="lookup.last_written = event.originalTarget.value; console.log(lookup.last_written);" />
<button onclick="lookup.add_statement(lookup.last_written, 'user-input')">add</button>
</body>