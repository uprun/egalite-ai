just rewrite very fast - egalite-ai</br>
</br>
Preemptive optimization is the root of all evil</br>
</br>
I don't want an LLM I want just an LM plus Prolog</br>
| basically I want natural looking Prolog</br>
коротка відповідь ліпша за довгу</br>
start with simple implementation and see where it gets you</br>
</br>
unfortunatelly or even fortunatelly you can find connection between anything</br>
it can be a silly connection but still a connection</br>
Everything is made of atoms</br>
| except for thoughts</br>
| except for magnetic fields</br>
| but this gives connection to thoughts and magnetic fields</br>

</br>
I will not reach levels of ChatGPT or DeepSeek R1 but I will try to explore alternative path</br>
I will start with reasoning in a form of chat</br>

</br>
but I might re-use simple models, simple LLM models</br>
in one of the videos of theo-3g he copied thinking part of r1 as a context to claude and asked same question and claude answered</br>
if I can provide some of the thinking part as an algorithm I might achieve good-enough results with less compute</br>
</br>
in unix philosophy every program should be short-lived</br>
| every communication should be in text
</br>
you can rewrite any rule - actually it is better not to rewrite rules<br>
| rules are part of the database<br>
I might add spaces around the parts of the rules in order to prevent accidental match</br>

</br>
Bad examples:</br>
"if A is a B and B has C then A has C", // unreadable </br>
Better examples:</br>
"Tom is a cat", "is a cat => has tail", "Tom has tail"// actually this is how I explained it to my son</br>
<script>
    lookup = {};
    lookup.last_written = "";
    lookup.facts = [
    
        "Tom is a cat", "is a cat => has tail", "Tom has tail"// actually this is how I explained it to my son
    ];

    lookup.get_combinations_ish = function(stuff, splitter)
    {
        var splitted = stuff.split(splitter);
        var rules = [];
        if ( splitted.length > 1)
        {
            for (let i = 1; i < splitted.length; i += 1) {
                var rule = {
                    from: splitted.slice(0, i).join(splitter),
                    to: splitted.slice(i).join(splitter)
                };
                rules.push(rule);
            }
        }
        //console.log(rules);
        return rules;
    };
    lookup.get_rules = function(stuff)
    {
        var result = lookup.get_combinations_ish(stuff, " => ");
        return result;
    };
    lookup.rewrite = function(stuff)
    {
        lookup.facts.push(stuff);
        var newFacts = [stuff];
        for(const fact of lookup.facts)
        {
            for(const maybe_rule of lookup.facts)
            {
                var rules = lookup.get_rules(maybe_rule);
                for (const rule of rules)
                {
                    if (fact.indexOf(rule.from) >= 0)
                    {
                        var combos = lookup.get_combinations_ish(fact, rule.from);
                        for(const c of combos)
                        {
                            var news = c.from + rule.to + c.to;
                            console.log(fact, rule, news);
                            newFacts.push(news);
                        }
                    }
                }
            }
        }
        lookup.facts.concat(newFacts);
    };
</script>
<input id="repl" onkeyup="lookup.last_written = event.originalTarget.value; console.log(lookup.last_written);" />
<button onclick="
    lookup.rewrite(lookup.last_written)">rewrite</button>