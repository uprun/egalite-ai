egalite-ai</br>
local chat-like reasoning</br>
</br>
Motto:</br>
Be readable</br>
Provide partial answer ASAP</br>
allow to break reasoning</br>
</br>
if A is a B and B has C then A has C</br>
vs</br>
A is B | B has C => A has C</br>
rewrite when "Tom is cat"</br>
Tom is cat | cat has C => Tom has C</br>
rewrite when "cat has tail"</br>
Tom is cat | cat has tail => Tom has tail</br>
rewrite when "cat has whiskers"</br>
Tom is cat | cat has whiskers => Tom has whiskers</br>
<script>
    lookup = {};
    lookup.last_written = "";
    lookup.statements = [
    ];

    lookup.text_statements = ["Tom is cat", "cat has tail", "cat has whiskers", "A is B | B has C => A has C"];

    lookup.get_combinations_ish = function(stuff, splitter)
    {
        var splitted = stuff.split(splitter);
        var rules = [];
        if ( splitted.length > 1)
        {
            for (let i = 1; i < splitted.length; i += 1) {
                var rule = {
                    from: splitted.slice(0, i).join(splitter),
                    to: splitted.slice(i).join(splitter)
                };
                rules.push(rule);
            }
        }
        //console.log(rules);
        return rules;
    };
    lookup.get_first_rule = function(stuff)
    {
        var result = lookup.get_combinations_ish(stuff, " => ")[0];
        return result;
    };
    lookup.add_statement = function(stuff, where_it_comes_from, chain_of_thought)
    {
        for(const existing of lookup.statements)
        {
            if(existing.original === stuff) 
            {
                return;
            }
        }
         
        if (stuff.indexOf(" => ") >= 0)
        {
            const to_add = {
                type: "rule",
                original: stuff,
                where_it_comes_from: where_it_comes_from,
                data: lookup.get_first_rule(stuff),
                chain_of_thought: chain_of_thought || [stuff]
            };
            lookup.statements.push(to_add);
            console.log(to_add);
        }
        else
        {
            const to_add = {
                type: "fact",
                original: stuff,
                where_it_comes_from: where_it_comes_from,
                data: stuff,
                chain_of_thought: chain_of_thought || [stuff]
            };
            lookup.statements.push(to_add);
            console.log(to_add);
        }
    };
    lookup.rewrite = function()
    {
        for(const fact of lookup.statements)
        {
            if (fact.type != "fact") continue;
            for(const rule of lookup.statements)
            {
                if (rule.type != "rule") continue;
                if (fact.data.indexOf(rule.data.from) >= 0)
                {
                    var combos = lookup.get_combinations_ish(fact.data, rule.data.from);
                    for(const c of combos)
                    {
                        var news = c.from + rule.data.to + c.to;
                        //console.log(fact, rule, news);
                        var chain_of_thought = (fact.chain_of_thought.slice()).concat([rule.original, news])
                        lookup.add_statement(news, 'derived-by-rule', chain_of_thought);
                    }
                }
            }
        }
        setTimeout(lookup.rewrite, 30);
    };
    setTimeout(lookup.rewrite, 30);
    for(var text of lookup.text_statements)
    {
        lookup.add_statement(text, 'predefined-data');
    }
</script>
<input id="repl" onkeyup="lookup.last_written = event.originalTarget.value; console.log(lookup.last_written);" />
<button onclick="lookup.add_statement(lookup.last_written, 'user-input')">add</button>