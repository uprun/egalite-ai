<script>
    // Helper: Check if a token is a variable (all uppercase letters)
function isVariable(token) {
  return /^[A-Z]+$/.test(token);
}

// Tokenize a string into words (by whitespace)
function tokenize(str) {
  return str.split(/\s+/);
}

// Unification: Try to match patternTokens against statementTokens,
// carrying along an existing substitution (if any).
// Returns a new substitution if matching succeeds, or null otherwise.
function matchPattern(patternTokens, statementTokens, substitution = {}) {
  if (patternTokens.length !== statementTokens.length) return null;
  // Clone the substitution object to avoid side-effects.
  let newSubst = { ...substitution };
  
  for (let i = 0; i < patternTokens.length; i++) {
    let p = patternTokens[i];
    let s = statementTokens[i];
    
    if (isVariable(p)) {
      if (newSubst[p] !== undefined) {
        // Variable already substituted: check consistency.
        if (newSubst[p] !== s) return null;
      } else {
        // Assign the substitution.
        newSubst[p] = s;
      }
    } else {
      // For non-variables, tokens must match exactly.
      if (p !== s) return null;
    }
  }
  return newSubst;
}

// Apply a substitution to a pattern (array of tokens).
function applySubstitution(patternTokens, substitution) {
  return patternTokens.map(token => (isVariable(token) ? (substitution[token] || token) : token));
}

// Parse a rule string like "A is B | B has C => A has C"
// into an object with an array of premise token arrays and a conclusion token array.
function parseRule(ruleStr) {
  // Split into premises and conclusion using "=>"
  let [premisesPart, conclusionPart] = ruleStr.split("=>").map(s => s.trim());
  // Premises can be separated by the pipe "|" symbol.
  let premises = premisesPart.split("|").map(p => tokenize(p.trim()));
  let conclusion = tokenize(conclusionPart);
  return { premises, conclusion };
}

// Apply a rule to a set of statements.
// For each combination of statements that match all premises,
// deduce the conclusion by applying the found substitution.
function applyRule(rule, statements) {
  let deduced = new Set();

  // Recursively try to match each premise.
  function recursiveMatch(premiseIndex, currentSubst) {
    if (premiseIndex === rule.premises.length) {
      // All premises have been matched.
      // Generate the conclusion by substituting the variables.
      let conclusionTokens = applySubstitution(rule.conclusion, currentSubst);
      let newStatement = conclusionTokens.join(" ");
      deduced.add(newStatement);
      return;
    }
    
    // For the current premise, try every statement.
    let premisePattern = rule.premises[premiseIndex];
    for (let statement of statements) {
      let statementTokens = tokenize(statement);
      let newSubst = matchPattern(premisePattern, statementTokens, currentSubst);
      if (newSubst) {
        // If this statement matches the current premise, continue with the next.
        recursiveMatch(premiseIndex + 1, newSubst);
      }
    }
  }

  recursiveMatch(0, {});
  return deduced;
}

// ----------------------------
// Testing the implementation
// ----------------------------

// Given statements
let statements = [
  "Tom is cat",
  "cat has tail",
  "cat has whiskers",
  "human is mortal"
];

// Given rule: if A is B and B has C then A has C.
let ruleStr = "A is B | B has C => A has C";
let rule = parseRule(ruleStr);

// Apply the rule to our statements.
let newStatements = applyRule(rule, statements);

// Log the deduced statements.
console.log("Deduced Statements:");
for (let stmt of newStatements) {
  console.log(stmt);
}

// Expected output:
// Tom has tail
// Tom has whiskers

// ----------------------------
// Example of adding another rule
// ----------------------------

// For instance, if you add a new rule: "A is B | B is C => A is C"
// (you might later add statements like "cat is animal" to trigger further inference)
let rule2Str = "A is B | B is C => A is C";
let rule2 = parseRule(rule2Str);

// You can then apply rule2 similarly:
let newStatementsRule2 = applyRule(rule2, statements);
console.log("\nDeduced Statements from Rule 2:");
for (let stmt of newStatementsRule2) {
  console.log(stmt);
}

</script>